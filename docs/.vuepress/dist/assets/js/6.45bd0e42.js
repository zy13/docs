(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{596:function(t,e,c){"use strict";c.r(e);var _=c(1),a=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,c=t._self._c||e;return c("div",{staticClass:"content"},[c("h2",{attrs:{id:"☆-调用setstate之后发生了什么"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#☆-调用setstate之后发生了什么","aria-hidden":"true"}},[t._v("#")]),t._v(" ☆-调用setState之后发生了什么")]),c("p",[t._v("在代码中调用 "),c("code",[t._v("setState")]),t._v(" 函数之后，"),c("code",[t._v("React")]),t._v(" 会将传入的参数对象与组件当前的状态合并，然后触发\n所谓的调和过程（"),c("code",[t._v("Reconciliation")]),t._v("）。")]),c("p",[t._v("经过"),c("strong",[t._v("调和过程")]),t._v("，"),c("code",[t._v("React")]),t._v(" 会以相对高效的方式根据新的状态构建 "),c("code",[t._v("React")]),t._v(" 元素树并且着手重新渲染整个 "),c("code",[t._v("UI")]),t._v("界面。")]),c("p",[t._v("在 "),c("code",[t._v("React")]),t._v(" 得到元素树之后，"),c("code",[t._v("React")]),t._v(" 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。")]),c("p",[t._v("在差异计算算法中，"),c("code",[t._v("React")]),t._v("能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。")])])}],!1,null,null,null);e.default=a.exports}}]);