(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{480:function(e,t,a){"use strict";a.r(t);var v=a(1),_=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"☆-vue中computed和watch的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#☆-vue中computed和watch的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" ☆ - Vue中computed和watch的区别")]),a("ul",[a("li",[a("p",[a("code",[e._v("computed")]),e._v(" 是计算属性，依赖其他属性计算值，并且 "),a("code",[e._v("computed")]),e._v(" 的值有缓存，只有当计算\n值变化才会返回内容。")])]),a("li",[a("p",[e._v("一对多：一个属性依赖多个属性")])]),a("li",[a("p",[e._v("必须要有一个返回值")])]),a("li",[a("p",[e._v("依赖属性为发生变化，调用缓存的值，否则重新计算")])]),a("li",[a("p",[e._v("只有函数形式")])]),a("li",[a("p",[a("code",[e._v("watch")]),e._v(" 监听data中属性，属性值发生变化时，就会执行回调，在回调中可以进行一些逻辑操作。")]),a("ul",[a("li",[e._v("多对一：多个属性依赖一个属性")]),a("li",[e._v("监听的属性需要在data中初始化")]),a("li",[e._v("根据使用场景，来使用可以设置一些属性，")]),a("li",[e._v("函数形式对象形式，对象形式可以设置immediate喝deep属性，分别表示是否立即执行与深层监听")])])])]),a("h2",{attrs:{id:"☆-vue中-route和-router的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#☆-vue中-route和-router的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" ☆ - Vue中$route和$router的区别")]),a("ul",[a("li",[a("p",[a("code",[e._v("$route")]),e._v(" 是当前组件映射的“路由信息对象”，包括 "),a("code",[e._v("path")]),e._v("，"),a("code",[e._v("params")]),e._v("，"),a("code",[e._v("hash")]),e._v("，"),a("code",[e._v("query")]),e._v("，"),a("code",[e._v("fullPath")]),e._v("，"),a("code",[e._v("matched")]),e._v("，"),a("code",[e._v("name")]),e._v(" 等路由信息参数。")])]),a("li",[a("p",[a("code",[e._v("$router")]),e._v("是整个应用的“路由实例”对象，包括了路由的跳转方法，钩子函数等。")])])])])}],!1,null,null,null);t.default=_.exports}}]);